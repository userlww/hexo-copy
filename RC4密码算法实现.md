---
title: RC4密码算法实现
copyright: false
date: 2018-01-08 08:39:51
tags: [密码学,序列密码,RC4]
categories: [密码学,序列密码]

---
### 写在前面
&nbsp;&nbsp;&nbsp;密码学实验已经做了好几个星期了，始终没能跟上老师的脚步，一来最近在复习基础只是准备下学期找实习，二来也在学习一些新的技术，而且越来越懒，所以没有花太多时间在密码学上面，这篇文章用来整理一下RC4密码的实现思路，也是为了帮助自己更好的理解。
### 参考
[RC4加密算法的原理及实现][1]
[维基百科-RC4][2]


  [1]: http://blog.csdn.net/lc_910927/article/details/37599161
  [2]: https://zh.wikipedia.org/wiki/RC4
  
### 概述
&nbsp;&nbsp;&nbsp;RC4算法是一种比较典型的序列密码，序列密码最早的起源可以追溯到1917年的Vernam算法，简单来说，序列密码是指明文消息按字符（比如二元字符）逐一字符进行加密的密码算法，序列密码可以分为同步序列密码和自同步序列密码。
### 算法中的几个重要变量

 - 密钥流：密钥流是RC4的关键，是由明文和密钥生成的，密钥流的长度和明文的长度是对应的，同时加密得到的密文和密钥流的长度也是相同的。
 -  状态向量S:状态向量的长度为2的8次方也就是256，存放在数组S中，称为S盒。
 -  临时向量T:长度也是256，如果密钥长度也是256个字节，就直接将密钥的值赋给T，否则轮转的将密钥的每个字节赋给T；
 -  密钥K：长度为1-256字节，注意密钥的长度与名文森和密钥流的长度没有必然的关系，通常密钥的长度为16字节（128比特）。
### RC4的实现步骤
#### 初始化S和T

>S[0]-s[255]的值就是其对应的下标的值,轮转的将密钥的值赋给T；

>         for(int i=0;i<256;i++)
>           {
>              s[i]=i;
>              T[i]=K[imodKlen];
>            }

#### 初始排列S
>       int j=0;
>       for(int i=0;i<256;i++)
>        {
>         j=(j+S[i]+T[i])mod256;
>         swao(S[i],S[j]);

#### 产生密钥流
>      int i=0,j=0;
>      for(int r=0;r<Mlen;r++)    //Mlen为明文长度
>       {
>         i=(i+1)mod256;
>         j=(j+S[i]mod256;
>         swap(S[i],S[i])mod256;
>          t=(S[i]+S[j])mod256;
>          k[r]=S[t];

下面是实现RC4的C++代码
。。。。正在书写中


